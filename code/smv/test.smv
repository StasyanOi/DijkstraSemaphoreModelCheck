MODULE main
 VAR
   semaphore : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   proc1     : process user(semaphore);
   proc2     : process user(semaphore);
   proc3     : process user(semaphore);
   proc4     : process user(semaphore);
   proc5     : process user(semaphore);
 ASSIGN
   init(semaphore) := 3;

LTLSPEC  (semaphore = 1 -> G (      F (proc1.state = critical & proc2.state != critical & proc3.state != critical & proc4.state != critical & proc5.state != critical)
                                  | F (proc1.state != critical & proc2.state = critical & proc3.state != critical & proc4.state != critical & proc5.state != critical)
                                  | F (proc1.state != critical & proc2.state != critical & proc3.state = critical & proc4.state != critical & proc5.state != critical)
                                  | F (proc1.state != critical & proc2.state != critical & proc3.state != critical & proc4.state = critical & proc5.state != critical)
                                  | F (proc1.state != critical & proc2.state != critical & proc3.state != critical & proc4.state != critical & proc5.state = critical)))

LTLSPEC  (                  G (     F (proc1.state = critical)
                                  & F (proc4.state = critical)
                                  & F (proc3.state = critical)
                                  & F (proc2.state = critical)
                                  & F (proc5.state = critical)))



MODULE user(semaphore)
 VAR
   state : {idle, waiting, entering, critical, exiting};
 ASSIGN
   init(state) := idle;
   next(state) :=
     case
       state = idle                                          : entering;
       state = waiting & semaphore > 0                       : critical;
       state = entering & semaphore > 0                      : critical;
       state = entering & semaphore <= 0                     : waiting;
       state = critical                                      : exiting;
       state = exiting &  semaphore < 3                      : idle;
       TRUE                                                  : state;
     esac;
   next(semaphore) :=
     case
       state = entering & semaphore > 0 : semaphore - 1;
       state = waiting & semaphore > 0 : semaphore - 1;
       state = exiting & semaphore < 3  : semaphore + 1;
       TRUE             : semaphore;
     esac;

 FAIRNESS
   running